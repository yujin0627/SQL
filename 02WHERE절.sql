-- WHERE절

SELECT * FROM EMPLOYEES;

SELECT FIRST_NAME, JOB_ID FROM EMPLOYEES WHERE JOB_ID = 'IT_PROG';
SELECT * FROM EMPLOYEES WHERE SALARY >= 15000;
SELECT * FROM EMPLOYEES WHERE SALARY < 10000;
SELECT * FROM EMPLOYEES WHERE DEPARTMENT_ID <> 50; -- 같지 않음
SELECT * FROM EMPLOYEES WHERE FIRST_NAME = 'Steven'; -- 데이터는 대소문자 구분함
SELECT * FROM EMPLOYEES WHERE HIRE_DATE = '04/01/30'; -- 날짜도 문자열로 찾으면 됩니다.
SELECT * FROM EMPLOYEES WHERE HIRE_DATE <= '04/01/30'; -- 날짜도 날짜순의 비교가 가능하다.

-- BETWEEN A AND B (이상~이하)
SELECT * FROM EMPLOYEES WHERE SALARY BETWEEN 10000 AND 15000;
SELECT * FROM EMPLOYEES WHERE HIRE_DATE BETWEEN '03/01/01' AND '03/12/31'; -- 03 년도에 들어온 사람 찾기

-- IN 연산자
SELECT * FROM EMPLOYEES WHERE DEPARTMENT_ID IN (50,60,70); -- 50, 60, 70인 데이터만 나옴
SELECT * FROM EMPLOYEES WHERE DEPARTMENT_ID NOT IN (50,60,70); -- 50, 60, 70이 아닌 데이터만 나옴
SELECT * FROM EMPLOYEES WHERE DEPARTMENT_ID NOT IN (50,60,70) ORDER BY DEPARTMENT_ID DESC; -- 50, 60, 70이 아닌 데이터가 내림차순으로 나옴
SELECT * FROM EMPLOYEES WHERE JOB_ID IN ('IT_PROG', 'AD_VP'); -- 문자로도 찾을 수 있음

-- LIKE 연산자 ( %, _ )
SELECT * FROM EMPLOYEES WHERE HIRE_DATE LIKE '03%'; -- 03으로 시작하는 모든 데이터
SELECT * FROM EMPLOYEES WHERE HIRE_DATE LIKE '%01'; -- 01으로 끝나는 모든 데이터
SELECT * FROM EMPLOYEES WHERE HIRE_DATE LIKE '%05%'; -- 05가 들어간 모든 데이터
SELECT * FROM EMPLOYEES WHERE FIRST_NAME LIKE '_ar%'; -- _는 자릿수
SELECT * FROM EMPLOYEES WHERE HIRE_DATE LIKE '___05%'; -- 05월을 찾아줌

-- IS NULL, IS NOT NULL
SELECT * FROM EMPLOYEES;
SELECT * FROM EMPLOYEES WHERE COMMISSION_PCT = NULL; -- X NULL값을 가지는 데이터가 없는 것 같지만 이렇게 사용하면 조회되지 않음
SELECT * FROM EMPLOYEES WHERE COMMISSION_PCT IS NULL; -- NULL 인 값만 조회
SELECT * FROM EMPLOYEES WHERE COMMISSION_PCT IS NOT NULL; -- NULL 이 아닌 값만 조회

-- AND, OR - AND가 OR보다 연산순위기 빠르다.
SELECT * FROM EMPLOYEES WHERE JOB_ID = 'IT_PROG' OR SALARY >= 5000; -- 둘 중 하나만 만족해도 나옴
SELECT * FROM EMPLOYEES WHERE JOB_ID = 'IT_PROG' AND SALARY >= 5000; -- 둘 다 만족해야 나옴
SELECT * FROM EMPLOYEES WHERE JOB_ID = 'IT_PROG' OR JOB_ID = 'FI_MGR' AND SALARY >= 5000; -- AND가 먼저 동작
SELECT * FROM EMPLOYEES WHERE (JOB_ID = 'IT_PROG' OR JOB_ID = 'FI_MGR') AND SALARY >= 5000; --()사용하여 우선순위 변경

-- NOT 부정의 의미
SELECT * FROM EMPLOYEES WHERE DEPARTMENT_ID IN (50, 60, 70); -- 50, 60, 70 인 데이터
SELECT * FROM EMPLOYEES WHERE DEPARTMENT_ID NOT IN (50, 60, 70); -- 50, 60, 70 이 아닌 데이터
SELECT * FROM EMPLOYEES WHERE JOB_ID LIKE '%IT%'; -- IT가 들어가는 데이터
SELECT * FROM EMPLOYEES WHERE JOB_ID NOT LIKE '%IT%'; -- IT가 들어가지 않는 데이터

--------------------------------------------------------------------------------
-- ORDER BY 구문
SELECT * FROM EMPLOYEES ORDER BY SALARY; -- ASC가 오름차순( 디폴트 값이라 생략가능 )
SELECT * FROM EMPLOYEES ORDER BY SALARY DESC; -- DESC가 내림차순
SELECT * FROM EMPLOYEES ORDER BY DEPARTMENT_ID, SALARY DESC; -- 먼저 부서아디디로 정렬, 동순위에 대해서 SALARY로 내림차순 정렬 , 사용하여 여러가지 사용가능

SELECT FIRST_NAME, SALARY * 12 AS 연봉 FROM EMPLOYEES ORDER BY 연봉 DESC; -- 엘리어스를 정렬에서 사용할 수 있음
SELECT FIRST_NAME, SALARY * 12 AS 연봉 FROM EMPLOYEES WHERE 연봉 >= 10000; -- 작동안됨 WHERE절이 SELECT 보다 먼저 실행되기 때문

SELECT FIRST_NAME, SALARY FROM EMPLOYEES WHERE DEPARTMENT_ID = 50 ORDER BY FIRST_NAME; -- DEPARTMENT_ID = 50 를 찾고 FIRST_NAME 기준으로 오름차순
SELECT FIRST_NAME, SALARY, DEPARTMENT_ID FROM EMPLOYEES WHERE DEPARTMENT_ID = 50 ORDER BY FIRST_NAME; 